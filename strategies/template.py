# --- ОБЯЗАТЕЛЬНЫЕ ИМПОРТЫ ---import pandas as pdimport pandas_ta as taimport loggingfrom queue import Queuefrom core.event import MarketEvent, SignalEventfrom strategies.base_strategy import BaseStrategy# --- 1. ОПРЕДЕЛЕНИЕ КЛАССА ---# Название класса должно быть уникальным и понятным. Он должен наследоваться от BaseStrategy.class MyAwesomeStrategy(BaseStrategy):    # --- 2. КОНСТРУКТОР: "ПАСПОРТ" СТРАТЕГИИ ---    def __init__(self, events_queue: Queue):        super().__init__(events_queue)                # Здесь вы задаете все ключевые параметры вашей стратегии.        self.name = "MyAwesomeStrategy"          # Уникальное имя для логов        self.figi = "BBG004730RP0"               # FIGI инструмента (например, LKOH)        self.candle_interval = "1hour"            # Таймфрейм (1min, 5min, 15min, 1hour, 1day)        self.stop_loss_percent = 2.0              # Процент для стоп-лосса        self.take_profit_percent = 5.0            # Процент для тейк-профита                # Внутренние переменные для хранения состояния (если нужно)        self.data_history = []    # --- 3. ПОДГОТОВКА ДАННЫХ: РАСЧЕТ ИНДИКАТОРОВ ---    def prepare_data(self, data: pd.DataFrame) -> pd.DataFrame:        """        Этот метод вызывается один раз перед началом бэктеста.        Ваша задача - добавить в DataFrame 'data' все нужные вам индикаторы.        """        logging.info(f"Стратегия '{self.name}' рассчитывает свои индикаторы...")                # Пример: расчет RSI и двух скользящих средних        data.ta.rsi(length=14, append=True, col_names=('RSI_14',))        data.ta.sma(length=50, append=True, col_names=('SMA_50',))        data.ta.sma(length=200, append=True, col_names=('SMA_200',))                # Важно: удаляем строки с пустыми значениями (NaN), которые появляются        # в начале после расчета индикаторов.        data.dropna(inplace=True)        data.reset_index(drop=True, inplace=True)                return data    # --- 4. ЛОГИКА СИГНАЛОВ: ПРИНЯТИЕ РЕШЕНИЙ ---    def calculate_signals(self, event: MarketEvent):        """        Этот метод вызывается для КАЖДОЙ свечи в истории.        Здесь вы анализируете данные и решаете, нужно ли покупать или продавать.        """        # Сохраняем последние 2 свечи для анализа        self.data_history.append(event.data)        if len(self.data_history) > 2:            self.data_history.pop(0)        if len(self.data_history) < 2:            return        last_candle = self.data_history[-1]                # Пример логики для входа в ПОКУПКУ        if last_candle['RSI_14'] < 30 and last_candle['SMA_50'] > last_candle['SMA_200']:            # Если условия выполнены, создаем SignalEvent и кладем его в очередь            signal = SignalEvent(figi=self.figi, direction="BUY", strategy_id=self.name)            self.events_queue.put(signal)            return        # Пример логики для ВЫХОДА (продажи)        if last_candle['RSI_14'] > 70:            signal = SignalEvent(figi=self.figi, direction="SELL", strategy_id=self.name)            self.events_queue.put(signal)            return