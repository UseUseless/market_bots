import osimport pandas as pdimport argparseimport loggingfrom typing import get_args, Dict, Any, Typefrom tqdm import tqdmimport numpy as npfrom concurrent.futures import ThreadPoolExecutor, as_completedfrom core.backtest_engine import run_backtest_sessionfrom analyzer import BatchTestAnalyzerfrom config import PATH_CONFIG, DATA_FILE_EXTENSION, BACKTEST_CONFIG, STRATEGY_CONFIG, RISK_CONFIGfrom strategies import AVAILABLE_STRATEGIESfrom core.risk_manager import RiskManagerTypefrom strategies.base_strategy import BaseStrategylogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')logging.getLogger('backtester').setLevel(logging.WARNING)def _prepare_backtest_settings(    strategy_class: Type[BaseStrategy],    exchange: str,    instrument: str,    interval: str,    risk_manager_type: str) -> Dict[str, Any]:    """Собирает и возвращает словарь с настройками для одного запуска бэктеста."""    return {        "strategy_class": strategy_class,        "exchange": exchange,        "instrument": instrument,        "interval": interval,        "risk_manager_type": risk_manager_type,        "initial_capital": BACKTEST_CONFIG["INITIAL_CAPITAL"],        "commission_rate": BACKTEST_CONFIG["COMMISSION_RATE"],        "data_dir": PATH_CONFIG["DATA_DIR"],        "trade_log_path": None,  # В batch-режиме логи сделок не сохраняем        "strategy_config": STRATEGY_CONFIG,        "risk_config": RISK_CONFIG,    }def _calculate_buy_and_hold_pnl(exchange: str, interval: str, instrument: str) -> float:    """    Загружает исторические данные и рассчитывает PnL для стратегии Buy & Hold.    Возвращает результат в процентах.    """    try:        data_path = os.path.join(PATH_CONFIG["DATA_DIR"], exchange, interval, f"{instrument}{DATA_FILE_EXTENSION}")        historical_data = pd.read_parquet(data_path)        if historical_data.empty:            return np.nan        initial_capital = BACKTEST_CONFIG["INITIAL_CAPITAL"]        entry_price = historical_data['open'].iloc[0]        exit_price = historical_data['close'].iloc[-1]        if entry_price == 0: # Защита от деления на ноль            return np.nan        bh_pnl = (exit_price - entry_price) * (initial_capital / entry_price)        return (bh_pnl / initial_capital) * 100    except Exception as e:        logging.warning(f"Не удалось рассчитать Buy&Hold для '{instrument}': {e}")        return np.nandef run_single_test_task(args):    """Задача для выполнения одного бэктеста в отдельном потоке."""    strategy_name, exchange, interval, risk_manager_type, instrument = args    strategy_class = AVAILABLE_STRATEGIES[strategy_name]    # Мы не будем сохранять логи сделок и отчеты для каждого инструмента в batch-режиме,    # чтобы не засорять папки. Оптимизатор будет заниматься этим более осмысленно.    # Цель batch-теста - быстрый прогон и сбор статистики.    backtest_settings = _prepare_backtest_settings(        strategy_class, exchange, instrument, interval, risk_manager_type    )    results = run_backtest_session(backtest_settings)    bh_pnl_percent = _calculate_buy_and_hold_pnl(exchange, interval, instrument)    if results["status"] == "success" and not results["trades_df"].empty:        pnl_percent = (results["total_pnl"] / results["initial_capital"]) * 100        return {            "instrument": instrument,            "pnl_percent": pnl_percent,            "bh_pnl_percent": bh_pnl_percent,            "total_trades": len(results["trades_df"])        }    return Nonedef run_batch_test(strategy_name: str, exchange: str, interval: str, risk_manager_type: str, data_dir: str = PATH_CONFIG["DATA_DIR"]):    """    Запускает бэктест указанной стратегии на всех .parquet файлах    в указанной директории данных.    """    logging.info(f"--- Запуск пакетного тестирования для стратегии '{strategy_name}' ---")    # Собираем полный путь к папке с данными для нужного интервала (например, "data/5min")    interval_path = os.path.join(data_dir, exchange, interval)    # Проверяем, существует ли такая папка    if not os.path.isdir(interval_path):        logging.error(f"Ошибка: Директория с данными не найдена: {interval_path}")        return    # Получаем список всех .parquet файлов в директории    data_files = [f for f in os.listdir(interval_path) if f.endswith(DATA_FILE_EXTENSION)]    # Проверяем, нашлись ли вообще файлы для тестирования    if not data_files:        logging.warning(f"В директории {interval_path} не найдено файлов данных (.parquet).")        return    total_files = len(data_files)    logging.info(f"Найдено {total_files} инструментов для тестирования.")    tasks = [(strategy_name, exchange, interval, risk_manager_type, os.path.splitext(f)[0]) for f in data_files]    results_list = []    # Используем os.cpu_count() для оптимального количества потоков    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:        future_to_task = {executor.submit(run_single_test_task, task): task for task in tasks}        for future in tqdm(as_completed(future_to_task), total=len(tasks), desc="Общий прогресс"):            try:                result = future.result()                if result:                    results_list.append(result)            except Exception as e:                task_args = future_to_task[future]                instrument_name = task_args[4]                logging.error(f"Ошибка при обработке инструмента '{instrument_name}': {e}", exc_info=True)    if not results_list:        logging.warning("Ни один из бэктестов не произвел сделок.")        return    results_df = pd.DataFrame(results_list)    analyzer = BatchTestAnalyzer(results_df, strategy_name, interval, risk_manager_type)    analyzer.generate_summary_report()    logging.info("\n--- Пакетное тестирование завершено ---")def main():    """    Отвечает за парсинг аргументов и вызов основной логики тестирования.    """    parser = argparse.ArgumentParser(description="Менеджер пакетного тестирования стратегий.")    valid_rms = get_args(RiskManagerType)    parser.add_argument("--strategy", type=str, required=True, help="Имя стратегии для тестирования.")    parser.add_argument("--exchange", type=str, required=True, choices=['tinkoff', 'bybit'],                        help="Биржа для тестирования.")    parser.add_argument("--interval", type=str, required=True, help="Интервал данных.")    parser.add_argument("--rm", dest="risk_manager_type", type=str, default="FIXED", choices=valid_rms,                        help="Модель управления риском.")    args = parser.parse_args()    run_batch_test(args.strategy, args.exchange, args.interval, args.risk_manager_type)if __name__ == "__main__":    main()