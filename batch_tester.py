import osimport subprocess # Модуль для запуска дочерних процессов (нашего run_backtest.py)import argparseimport sysimport loggingfrom typing import get_argsfrom tqdm import tqdmfrom config import PATH_CONFIG, DATA_FILE_EXTENSIONfrom core.risk_manager import RiskManagerTypelogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')def run_batch_test(strategy_name: str, exchange: str, interval: str, risk_manager_type: str, data_dir: str = PATH_CONFIG["DATA_DIR"]):    """    Запускает бэктест указанной стратегии на всех .parquet файлах    в указанной директории данных.    """    logging.info(f"--- Запуск пакетного тестирования для стратегии '{strategy_name}' ---")    # Собираем полный путь к папке с данными для нужного интервала (например, "data/5min")    interval_path = os.path.join(data_dir, exchange, interval)    # Проверяем, существует ли такая папка    if not os.path.isdir(interval_path):        logging.error(f"Ошибка: Директория с данными не найдена: {interval_path}")        return    # Получаем список всех .parquet файлов в директории    data_files = [f for f in os.listdir(interval_path) if f.endswith(DATA_FILE_EXTENSION)]    # Проверяем, нашлись ли вообще файлы для тестирования    if not data_files:        logging.warning(f"В директории {interval_path} не найдено файлов данных (.parquet).")        logging.warning("Убедитесь, что вы скачали данные с помощью download_data.py")        return    total_files = len(data_files)    logging.info(f"Найдено {total_files} инструментов для тестирования.")    # Запускаем цикл по каждому найденному файлу    for filename in tqdm(data_files, desc="Общий прогресс", unit="инструмент"):        instrument = os.path.splitext(filename)[0]        logging.info(f"\n--- Тестирование instrument: {instrument} ---")        command = [            sys.executable, "run_backtest.py",            "--strategy", strategy_name,            "--exchange", exchange,            "--instrument", instrument,            "--rm", risk_manager_type,            "--interval", interval        ]                # Запускаем run_backtest.py как отдельный дочерний процесс и ждем его завершения        # Это гарантирует, что каждый запуск будет чистым и независимым        subprocess.run(command)    logging.info("\n--- Пакетное тестирование завершено ---")def main():    """    Отвечает за парсинг аргументов и вызов основной логики тестирования.    """    parser = argparse.ArgumentParser(description="Менеджер пакетного тестирования стратегий.")    valid_rms = get_args(RiskManagerType)    parser.add_argument(        "--strategy",        type=str,        required=True,        help="Имя стратегии для тестирования (из реестра в run_backtest.py)."    )    parser.add_argument(        "--exchange",        type=str,        required=True,        choices=['tinkoff', 'bybit'],        help="Биржа для пакетного тестирования.")    parser.add_argument(        "--interval",        type=str,        required=True,        help="Интервал данных (имя папки в директории /data)."    )    parser.add_argument(        "--rm",        dest="risk_manager_type",        type=str,        default="FIXED",  # Оставляем FIXED по умолчанию для обратной совместимости        choices=valid_rms,        help="Модель управления риском (по умолчанию: FIXED)."    )    args = parser.parse_args()    run_batch_test(        strategy_name=args.strategy,        exchange=args.exchange,        interval=args.interval,        risk_manager_type=args.risk_manager_type    )if __name__ == "__main__":    main()