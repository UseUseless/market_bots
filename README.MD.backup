# Market Bots

Cобытийно-ориентированный фреймворк на Python для разработки, бэктестинга и (в будущем) запуска алгоритмических торговых стратегий в sandbox и live режимах на Tinkoff бирже (возможно на криптобиржах)

## О проекте

**Текущие возможности:**
*   **Базовый бэктестер:** Базовая симуляция работы стратегии на исторических данных свеча за свечой.
*   **Работа с локальными данными:** Бэктест проводится на предварительно скачанных данных.
*   **Возможность скачивания исторических данных** Скачивание происходит через API Tinkoff
*   **Возможность добавления стратегий:** Добавление новых стратегий наследованием от абстрактного базового класса.
*   **Базовый анализ:** Генерация отчетов с ключевыми метриками (PnL, Win Rate, Max Drawdown и др.) и графиком капитала.
*   **Массовое тестирование:** Возможность запуска одной стратегии сразу на множестве скачанных инструментов.


## Архитектура

Основной принцип работы фреймворка — разделение логики на независимые компоненты, которые общаются через центральную очередь событий.

![Схема архитектуры](docs/WorkFlow.png)


## Быстрый старт

Тестировал на Python 3.12.10.

Клонируйте репозиторий и установите все необходимые зависимости в виртуальное окружение.

```bash
# Клонировать репозиторий
git clone [URL_ВАШЕГО_РЕПОЗИТОРИЯ]
cd market_bots

# Создать и активировать виртуальное окружение
python -m venv .venv
source .venv/bin/activate  	# Для Linux/MacOS
.venv\Scripts\activate   	# Для Windows

# Установить зависимости
pip install -r requirements.txt
```

### Конфигурация

Для работы с API Tinkoff необходимо получить токен.

1.  Скопируйте файл `.env.example` и переименуйте его в `.env`.
2.  Откройте файл `.env` и вставьте свой **боевой токен** (с правами "только для чтения") в переменную `TINKOFF_TOKEN_REAL`. Этот токен необходим для скачивания исторических данных.
    ```ini
    # .env
    TINKOFF_TOKEN_REAL=t.YourRealApiTokenGoesHere
    ...
    ```

## Порядок работы

### Шаг 1: Скачивание данных

Бэктестер работает с локальными данными в формате `.parquet`. 
Чтобы скачать данные для нужного инструмента, используйте скрипт `download_data.py`.

**Пример:** Скачать 5-минутные свечи для Сбербанка (`BBG004730N88`).
```bash
python download_data.py --figi BBG004730N88 --interval 5min
```
*   `--figi`: Один или несколько FIGI через пробел.
*   `--interval`: Таймфрейм (`1min`, `5min`, `15min`, `1hour`, `1day`).

Скачанные файлы будут храниться в папке `data/{interval}/`.

### Шаг 2: Создание своей стратегии

1.  Создайте новый Python-файл в папке `strategies/` (например, `my_strategy.py`).
2.  Создайте в нем класс, который наследуется от `BaseStrategy`.
3.  Измените аттрибуты и методы класса:
    *   Определите свойства `@property` для `candle_interval`, `stop_loss_percent`, `take_profit_percent`.
    *   Реализуйте методы `prepare_data` (для расчета индикаторов) и `calculate_signals` (для торговой логики):
	1) prepare_data
	Этот метод отвечает за расчет технических индикаторов и т.п.
	На вход (data: pd.DataFrame): Получает "сырой" DataFrame с историческими данными, содержащий колонки time, open, high, low, close, volume.
	Вы делаете с этими данными что вам необходимо.
	На выход (-> pd.DataFrame): Должен вернуть DataFrame, но уже преоборазованный Вами так, как нужно Вашей стратегии. (с индикаторами, очищенный от строк с NaN значениями, которые появляются в начале после расчетов и т.д.)
	2) calculate_signals
	Вызывается для каждой свечи и решает, нужно ли подавать сигнал.
	На вход (event: MarketEvent): Получает объект MarketEvent, у которого поле event.data содержит одну строку из DataFrame со всеми ценами и индикаторами для текущей свечи.
	Что делает: Вы анализируете данные в event.data и, если ваши торговые условия выполняются, генерируете событие SignalEvent и кладете его в общую очередь.
```python
# Пример генерации сигнала на покупку
if last_candle['close'] > last_candle['EMA_50']:
    signal = SignalEvent(figi=self.figi, direction="BUY", strategy_id=self.name)
    self.events_queue.put(signal)
```

4.  Зарегистрируйте свою стратегию в "реестре" `AVAILABLE_STRATEGIES` в файле `run.py`, а также не забудьте её импортировать в этот файл.

### Шаг 3: Запуск бэктеста

#### Запуск для одного инструмента

Используйте `run.py` для детального тестирования на одном инструменте.

**Пример:** Запустить стратегию `triple_filter` на Сбербанке.
```bash
python run.py --mode backtest --strategy triple_filter --figi BBG004730N88```
```
#### Массовый запуск (Batch Testing)

Используйте `batch_tester.py` для быстрого прогона стратегии на всех скачанных данных для определенного таймфрейма.

**Пример:** Запустить `triple_filter` на всех 5-минутных данных.
```bash
python batch_tester.py --strategy triple_filter --interval 5min
```

## Результаты работы

Все файлы, создаваемые в процессе работы, хранятся в соответствующих папках:

*   `data/`: Скачанные исторические данные в формате `.parquet`.
*   `logs/`: Детальные логи каждого запуска (`_run.log`) и CSV-файлы с перечнем всех сделок (`_trades.csv`).
*   `reports/`: Графические отчеты (`.png`) с кривой капитала и ключевыми метриками для каждого бэктеста.

## Кастомизация

### Настройка параметров бэктеста

Начальный капитал и комиссия задаются непосредственно в файле `core/portfolio.py` в конструкторе класса `Portfolio`.

```python
# core/portfolio.py
class Portfolio:
    def __init__(self, ..., initial_capital=100000.0, commission_rate=0.0005):
        # ...
```

### Настройка анализа результатов

Логика расчета метрик и построения графика находится в файле `analyzer.py`. Вы можете изменить или добавить новые метрики в методе `calculate_metrics` класса `BacktestAnalyzer`.

```python
# analyzer.py
class BacktestAnalyzer:
    def calculate_metrics(self) -> dict:
        # ...
        # Здесь можно добавить расчет других коэффициентов
        # ...
        return {
            "Total PnL": ...,
            "Win Rate": ...,
            # "Another Coeff": ...,
        }
```