import osimport pandas as pdimport argparseimport loggingfrom tqdm import tqdmfrom datetime import datetimefrom app.utils.logging_setup import setup_global_loggingfrom concurrent.futures import ThreadPoolExecutor, as_completedfrom app.engines.backtest_engine import run_backtest_sessionfrom app.analyzers.factory import analyze_run_resultsfrom app.analyzers.batch_run_analyzer import BatchRunAnalyzerfrom app.strategies import AVAILABLE_STRATEGIESfrom app.core.risk.risk_manager import AVAILABLE_RISK_MANAGERSfrom config import PATH_CONFIG, DATA_FILE_EXTENSION, BACKTEST_CONFIGdef run_single_test_task(args):    """Задача для выполнения одного бэктеста и расчета ПОЛНОГО набора метрик."""    strategy_class, exchange, interval, risk_manager_type, instrument, strategy_params, rm_params = args    backtest_settings = {        "strategy_class": strategy_class,        "exchange": exchange,        "instrument": instrument,        "interval": interval,        "risk_manager_type": risk_manager_type,        "initial_capital": BACKTEST_CONFIG["INITIAL_CAPITAL"],        "commission_rate": BACKTEST_CONFIG["COMMISSION_RATE"],        "data_dir": PATH_CONFIG["DATA_DIR"],        "trade_log_path": None,  # Не сохраняем индивидуальные логи        "strategy_params": strategy_params,        "risk_manager_params": rm_params,    }    results = run_backtest_session(backtest_settings)    if results["status"] == "success":        metrics_series = analyze_run_results(            trades_df=results["trades_df"],            historical_data=results["enriched_data"],            initial_capital=BACKTEST_CONFIG["INITIAL_CAPITAL"],            exchange=exchange        )        metrics_series['instrument'] = instrument  # Добавляем имя инструмента для сборки DataFrame        return metrics_series    return Nonedef run_batch_test(strategy_name: str, exchange: str, interval: str, risk_manager_type: str):    logging.info(f"--- Запуск пакетного тестирования для стратегии '{strategy_name}' ---")    interval_path = os.path.join(PATH_CONFIG["DATA_DIR"], exchange, interval)    if not os.path.isdir(interval_path):        logging.error(f"Ошибка: Директория с данными не найдена: {interval_path}")        return    data_files = [f for f in os.listdir(interval_path) if f.endswith(DATA_FILE_EXTENSION)]    if not data_files:        logging.warning(f"В директории {interval_path} не найдено файлов данных (.parquet).")        return    logging.info(f"Найдено {len(data_files)} инструментов для тестирования.")    strategy_class = AVAILABLE_STRATEGIES[strategy_name]    rm_class = AVAILABLE_RISK_MANAGERS[risk_manager_type]    strategy_params = strategy_class.get_default_params()    rm_params = rm_class.get_default_params()    logging.info(f"Используемые параметры стратегии (из файла): {strategy_params}")    logging.info(f"Используемые параметры риск-менеджера (из файла): {rm_params}")    tasks = [(strategy_class, exchange, interval, risk_manager_type, os.path.splitext(f)[0], strategy_params, rm_params)             for f in data_files]    results_list = []    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:        future_to_task = {executor.submit(run_single_test_task, task): task for task in tasks}        for future in tqdm(as_completed(future_to_task), total=len(tasks), desc="Общий прогресс"):            try:                result = future.result()                if result is not None:                    results_list.append(result)            except Exception as e:                task_args = future_to_task[future]                instrument_name = task_args[4]                logging.error(f"Ошибка при обработке инструмента '{instrument_name}': {e}", exc_info=True)    if not results_list:        logging.warning("Ни один из бэктестов не вернул результатов.")        return    results_df = pd.DataFrame(results_list)    report_dir = PATH_CONFIG["REPORTS_BATCH_TEST_DIR"]    os.makedirs(report_dir, exist_ok=True)    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")    report_filename = f"{timestamp}_{strategy_name}_{interval}_{len(results_df)}instr.xlsx"    output_path = os.path.join(report_dir, report_filename)    report_generator = BatchRunAnalyzer(        results_df=results_df, strategy_name=strategy_name, interval=interval,        risk_manager_type=risk_manager_type, strategy_params=strategy_params, rm_params=rm_params    )    report_generator.generate_excel_report(output_path)    logging.info("\n--- Пакетное тестирование завершено ---")def main():    setup_global_logging(log_level=logging.INFO)    parser = argparse.ArgumentParser(description="Менеджер пакетного тестирования и генерации отчетов.")    valid_rms = list(AVAILABLE_RISK_MANAGERS.keys())    parser.add_argument("--strategy", type=str, required=True, help="Имя стратегии для тестирования.")    parser.add_argument("--exchange", type=str, required=True, choices=['tinkoff', 'bybit'], help="Биржа для тестирования.")    parser.add_argument("--interval", type=str, required=True, help="Интервал данных.")    parser.add_argument("--rm", dest="risk_manager_type", type=str, default="FIXED", choices=valid_rms, help="Модель управления риском.")    args = parser.parse_args()    run_batch_test(args.strategy, args.exchange, args.interval, args.risk_manager_type)if __name__ == "__main__":    main()