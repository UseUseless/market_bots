import osimport pandas as pdimport argparseimport loggingfrom tqdm import tqdmfrom datetime import datetimefrom concurrent.futures import ThreadPoolExecutor, as_completedfrom typing import Tuplefrom app.engines.backtest_engine import BacktestEnginefrom app.analyzers.reports.excel_report import ExcelReportGeneratorfrom app.analyzers.metrics.portfolio_metrics import PortfolioMetricsCalculatorfrom app.analyzers.metrics.benchmark_metrics import BenchmarkMetricsCalculatorfrom app.strategies import AVAILABLE_STRATEGIESfrom app.core.risk.risk_manager import AVAILABLE_RISK_MANAGERSfrom app.utils.logging_setup import setup_global_loggingfrom config import (    PATH_CONFIG, DATA_FILE_EXTENSION, BACKTEST_CONFIG, EXCHANGE_SPECIFIC_CONFIG)# Настраиваем логгер для вывода информации в консольlogger = logging.getLogger(__name__)def run_single_instrument_task(task_args: Tuple) -> pd.Series | None:    """    Задача для одного потока.    1. Запускает BacktestEngine для одного инструмента.    2. Рассчитывает полный набор метрик с помощью калькуляторов.    3. Возвращает pd.Series с результатами.    """    (strategy_class, exchange, interval, risk_manager_type, instrument,     strategy_params, rm_params) = task_args    # Собираем настройки для движка бэктеста    settings = {        "strategy_class": strategy_class,        "exchange": exchange,        "instrument": instrument,        "interval": interval,        "risk_manager_type": risk_manager_type,        "initial_capital": BACKTEST_CONFIG["INITIAL_CAPITAL"],        "commission_rate": BACKTEST_CONFIG["COMMISSION_RATE"],        "data_dir": PATH_CONFIG["DATA_DIR"],        "strategy_params": strategy_params,        "risk_manager_params": rm_params,        "trade_log_path": None,  # Не сохраняем индивидуальные логи сделок    }    try:        # Запускаем движок        engine = BacktestEngine(settings)        results = engine.run()        if results["status"] == "success":            # --- Расчет метрик с помощью новых, специализированных калькуляторов ---            annual_factor = EXCHANGE_SPECIFIC_CONFIG[exchange]["SHARPE_ANNUALIZATION_FACTOR"]            # 1. Метрики по сделкам нашей стратегии            portfolio_calc = PortfolioMetricsCalculator(                trades_df=results["trades_df"],                initial_capital=results["initial_capital"],                annualization_factor=annual_factor            )            portfolio_metrics = portfolio_calc.calculate_all()            # 2. Метрики для бенчмарка (Buy & Hold)            bench_calc = BenchmarkMetricsCalculator(                historical_data=results["enriched_data"],                initial_capital=results["initial_capital"],                annualization_factor=annual_factor            )            bench_metrics = bench_calc.calculate_all()            # 3. Собираем все в одну строку для итогового DataFrame            # Мы берем pnl_pct из бенчмарка и переименовываем его для совместимости            # со старым форматом отчета.            full_metrics = {**portfolio_metrics, 'pnl_bh_pct': bench_metrics['pnl_pct']}            full_metrics['instrument'] = instrument            return pd.Series(full_metrics)    except Exception as e:        # Логируем ошибку, но не останавливаем весь процесс        logger.error(f"Ошибка при обработке инструмента '{instrument}': {e}", exc_info=True)    return Nonedef main():    """    Главная функция: парсит аргументы, находит файлы, запускает многопоточный    бэктест и генерирует итоговый Excel-отчет.    """    setup_global_logging(log_level=logging.INFO)    parser = argparse.ArgumentParser(        description="Менеджер пакетного тестирования стратегий."    )    parser.add_argument("--strategy", type=str, required=True,                        choices=list(AVAILABLE_STRATEGIES.keys()),                        help="Имя стратегии для тестирования.")    parser.add_argument("--exchange", type=str, required=True,                        choices=['tinkoff', 'bybit'],                        help="Биржа, на данных которой проводится тест.")    parser.add_argument("--interval", type=str, required=True,                        help="Интервал данных (например, '5min', '1hour').")    parser.add_argument("--rm", dest="risk_manager_type", type=str, default="FIXED",                        choices=list(AVAILABLE_RISK_MANAGERS.keys()),                        help="Модель управления риском.")    args = parser.parse_args()    logger.info(f"--- Запуск пакетного тестирования для стратегии '{args.strategy}' ---")    logger.info(f"Биржа: {args.exchange}, Интервал: {args.interval}, Риск-менеджер: {args.risk_manager_type}")    # --- 1. Поиск файлов с данными ---    interval_path = os.path.join(PATH_CONFIG["DATA_DIR"], args.exchange, args.interval)    if not os.path.isdir(interval_path):        logger.error(f"Ошибка: Директория с данными не найдена: {interval_path}")        return    data_files = [f for f in os.listdir(interval_path) if f.endswith(DATA_FILE_EXTENSION)]    if not data_files:        logger.warning(f"В директории {interval_path} не найдено файлов данных ({DATA_FILE_EXTENSION}).")        return    logger.info(f"Найдено {len(data_files)} инструментов для тестирования.")    # --- 2. Подготовка задач для пула потоков ---    strategy_class = AVAILABLE_STRATEGIES[args.strategy]    rm_class = AVAILABLE_RISK_MANAGERS[args.risk_manager_type]    strategy_params = strategy_class.get_default_params()    rm_params = rm_class.get_default_params()    logger.info(f"Используются параметры стратегии по умолчанию: {strategy_params}")    logger.info(f"Используются параметры риск-менеджера по умолчанию: {rm_params}")    tasks = [        (strategy_class, args.exchange, args.interval, args.risk_manager_type,         os.path.splitext(f)[0], strategy_params, rm_params)        for f in data_files    ]    # --- 3. Запуск многопоточного выполнения ---    results_list = []    with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:        future_to_task = {executor.submit(run_single_instrument_task, task): task for task in tasks}        progress_bar = tqdm(as_completed(future_to_task), total=len(tasks), desc="Общий прогресс")        for future in progress_bar:            try:                result = future.result()                if result is not None:                    results_list.append(result)            except Exception as e:                # Дополнительное логирование, если исключение возникло на уровне future.result()                logger.error(f"Критическая ошибка в потоке: {e}", exc_info=True)    if not results_list:        logger.warning("Ни один из бэктестов не вернул корректных результатов.")        return    # --- 4. Генерация итогового Excel-отчета ---    results_df = pd.DataFrame(results_list)    report_dir = PATH_CONFIG["REPORTS_BATCH_TEST_DIR"]    os.makedirs(report_dir, exist_ok=True)    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")    report_filename = f"{timestamp}_{args.strategy}_{args.interval}_{len(results_df)}instr.xlsx"    output_path = os.path.join(report_dir, report_filename)    # Используем наш новый, специализированный генератор отчетов    excel_generator = ExcelReportGenerator(        results_df=results_df,        strategy_name=args.strategy,        interval=args.interval,        risk_manager_type=args.risk_manager_type,        strategy_params=strategy_params,        rm_params=rm_params    )    excel_generator.generate_excel_report(output_path)    logger.info("\n--- Пакетное тестирование успешно завершено ---")if __name__ == "__main__":    main()